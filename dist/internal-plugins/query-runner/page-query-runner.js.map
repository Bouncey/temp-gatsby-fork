{"version":3,"sources":["../../../src/internal-plugins/query-runner/page-query-runner.js"],"names":["_","require","Promise","os","store","emitter","queryRunner","queuedDirtyActions","active","exports","runQueries","uniq","a","payload","id","dirtyIds","findDirtyIds","runQueriesForIds","cleanIds","findIdsWithoutDataDependencies","on","action","push","node","runQueuedActions","state","getState","allTrackedIds","flatten","concat","values","componentDataDependencies","nodes","connections","difference","pages","map","p","path","layouts","l","ids","length","resolve","pagesAndLayouts","plObj","find","pl","components","component","concurrency","Math","min","cpus","actions","reduce","internal","type","compact"],"mappings":";;AAAA;;;;;;;AAOA,MAAMA,IAAIC,QAAS,QAAT,CAAV;AACA,MAAMC,UAAUD,QAAS,UAAT,CAAhB;AACA,MAAME,KAAKF,QAAS,IAAT,CAAX;;AAEA,MAAM,EAAEG,KAAF,EAASC,OAAT,KAAqBJ,QAAS,aAAT,CAA3B;AACA,MAAMK,cAAcL,QAAS,gBAAT,CAApB;;AAEA,IAAIM,qBAAqB,EAAzB;AACA,IAAIC,SAAS,KAAb;;AAEA;AACA;AACA;AACAC,QAAQC,UAAR,GAAqB,YAAY;AAC/B;AACAH,uBAAqBP,EAAEW,IAAF,CAAOJ,kBAAP,EAA2BK,KAAKA,EAAEC,OAAF,CAAUC,EAA1C,CAArB;AACA,QAAMC,WAAWC,aAAaT,kBAAb,CAAjB;AACA,QAAMU,iBAAiBF,QAAjB,CAAN;;AAEAR,uBAAqB,EAArB;;AAEA;AACA;AACA,QAAMW,WAAWC,gCAAjB;;AAEA;AACA,QAAMF,iBAAiBC,QAAjB,CAAN;;AAEAV,WAAS,IAAT;AACA;AACD,CAjBD;;AAmBAH,QAAQe,EAAR,CAAY,aAAZ,EAA0BC,UAAU;AAClCd,qBAAmBe,IAAnB,CAAwBD,MAAxB;AACD,CAFD;;AAIAhB,QAAQe,EAAR,CAAY,aAAZ,EAA0BC,UAAU;AAClCd,qBAAmBe,IAAnB,CAAwB,EAAET,SAASQ,OAAOE,IAAlB,EAAxB;AACD,CAFD;;AAIA,MAAMC,mBAAmB,YAAY;AACnC,MAAIhB,MAAJ,EAAY;AACVD,yBAAqBP,EAAEW,IAAF,CAAOJ,kBAAP,EAA2BK,KAAKA,EAAEC,OAAF,CAAUC,EAA1C,CAArB;AACA,UAAMG,iBAAiBD,aAAaT,kBAAb,CAAjB,CAAN;AACAA,yBAAqB,EAArB;;AAEA;AACA;AACA,UAAMW,WAAWC,gCAAjB;AACAF,qBAAiBC,QAAjB;AACD;AACF,CAXD;;AAaA;AACA;AACA;AACAb,QAAQe,EAAR,CAAY,yBAAZ,EAAsCI,gBAAtC;;AAEA,MAAML,iCAAiC,MAAM;AAC3C,QAAMM,QAAQrB,MAAMsB,QAAN,EAAd;AACA,QAAMC,gBAAgB3B,EAAEW,IAAF,CACpBX,EAAE4B,OAAF,CACE5B,EAAE6B,MAAF,CACE7B,EAAE8B,MAAF,CAASL,MAAMM,yBAAN,CAAgCC,KAAzC,CADF,EAEEhC,EAAE8B,MAAF,CAASL,MAAMM,yBAAN,CAAgCE,WAAzC,CAFF,CADF,CADoB,CAAtB;;AASA;AACA;AACA,SAAOjC,EAAEkC,UAAF,CACL,CACE,GAAGT,MAAMU,KAAN,CAAYC,GAAZ,CAAgBC,KAAKA,EAAEC,IAAvB,CADL,EAEE,GAAGb,MAAMc,OAAN,CAAcH,GAAd,CAAkBI,KAAM,YAAWA,EAAE1B,EAAG,EAAxC,CAFL,CADK,EAKLa,aALK,CAAP;AAOD,CApBD;;AAsBA,MAAMV,mBAAmBwB,OAAO;AAC9BA,QAAMzC,EAAEW,IAAF,CAAO8B,GAAP,CAAN;AACA,MAAIA,IAAIC,MAAJ,GAAa,CAAjB,EAAoB;AAClB,WAAOxC,QAAQyC,OAAR,EAAP;AACD;AACD,QAAMlB,QAAQrB,MAAMsB,QAAN,EAAd;AACA,SAAOxB,QAAQkC,GAAR,CACLK,GADK,EAEL3B,MAAM;AACJ,UAAM8B,kBAAkB,CAAC,GAAGnB,MAAMU,KAAV,EAAiB,GAAGV,MAAMc,OAA1B,CAAxB;AACA,UAAMM,QAAQD,gBAAgBE,IAAhB,CACZC,MAAMA,GAAGT,IAAH,KAAYxB,EAAZ,IAAmB,YAAWiC,GAAGjC,EAAG,EAAlB,KAAwBA,EADpC,CAAd;AAGA,QAAI+B,KAAJ,EAAW;AACT,aAAOvC,YAAYuC,KAAZ,EAAmBpB,MAAMuB,UAAN,CAAiBH,MAAMI,SAAvB,CAAnB,CAAP;AACD;AACD,WAAO,IAAP;AACD,GAXI,EAYL,EAAEC,aAAaC,KAAKC,GAAL,CAASjD,GAAGkD,IAAH,GAAUX,MAAnB,EAA2B,EAA3B,CAAf,EAZK,CAAP;AAcD,CApBD;;AAsBA,MAAM1B,eAAesC,WAAW;AAC9B,QAAM7B,QAAQrB,MAAMsB,QAAN,EAAd;AACA,SAAO4B,QAAQC,MAAR,CAAe,CAACxC,QAAD,EAAWM,MAAX,KAAsB;AAC1C,UAAME,OAAOF,OAAOR,OAApB;;AAEA;AACAE,eAAWA,SAASc,MAAT,CAAgBJ,MAAMM,yBAAN,CAAgCC,KAAhC,CAAsCT,KAAKT,EAA3C,CAAhB,CAAX;;AAEA;AACAC,eAAWA,SAASc,MAAT,CACTJ,MAAMM,yBAAN,CAAgCE,WAAhC,CAA4CV,KAAKiC,QAAL,CAAcC,IAA1D,CADS,CAAX;;AAIA,WAAOzD,EAAE0D,OAAF,CAAU3C,QAAV,CAAP;AACD,GAZM,EAYJ,EAZI,CAAP;AAaD,CAfD","file":"page-query-runner.js","sourcesContent":["/**\n * Jobs of this module\n * - Ensure on bootstrap that all invalid page queries are run and report\n *   when this is done\n * - Watch for when a page's query is invalidated and re-run it.\n */\n\nconst _ = require(`lodash`)\nconst Promise = require(`bluebird`)\nconst os = require(`os`)\n\nconst { store, emitter } = require(`../../redux`)\nconst queryRunner = require(`./query-runner`)\n\nlet queuedDirtyActions = []\nlet active = false\n\n// Do initial run of graphql queries during bootstrap.\n// Afterwards we listen \"API_RUNNING_QUEUE_EMPTY\" and check\n// for dirty nodes before running queries.\nexports.runQueries = async () => {\n  // Run queued dirty nodes now that we're active.\n  queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n  const dirtyIds = findDirtyIds(queuedDirtyActions)\n  await runQueriesForIds(dirtyIds)\n\n  queuedDirtyActions = []\n\n  // Find ids without data dependencies (i.e. no queries have been run for\n  // them before) and run them.\n  const cleanIds = findIdsWithoutDataDependencies()\n\n  // Run these pages\n  await runQueriesForIds(cleanIds)\n\n  active = true\n  return\n}\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nemitter.on(`DELETE_NODE`, action => {\n  queuedDirtyActions.push({ payload: action.node })\n})\n\nconst runQueuedActions = async () => {\n  if (active) {\n    queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n    await runQueriesForIds(findDirtyIds(queuedDirtyActions))\n    queuedDirtyActions = []\n\n    // Find ids without data dependencies (e.g. new pages) and run\n    // their queries.\n    const cleanIds = findIdsWithoutDataDependencies()\n    runQueriesForIds(cleanIds)\n  }\n}\n\n// Wait until all plugins have finished running (e.g. various\n// transformer plugins) before running queries so we don't\n// query things in a 1/2 finished state.\nemitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedActions)\n\nconst findIdsWithoutDataDependencies = () => {\n  const state = store.getState()\n  const allTrackedIds = _.uniq(\n    _.flatten(\n      _.concat(\n        _.values(state.componentDataDependencies.nodes),\n        _.values(state.componentDataDependencies.connections)\n      )\n    )\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  return _.difference(\n    [\n      ...state.pages.map(p => p.path),\n      ...state.layouts.map(l => `LAYOUT___${l.id}`),\n    ],\n    allTrackedIds\n  )\n}\n\nconst runQueriesForIds = ids => {\n  ids = _.uniq(ids)\n  if (ids.length < 1) {\n    return Promise.resolve()\n  }\n  const state = store.getState()\n  return Promise.map(\n    ids,\n    id => {\n      const pagesAndLayouts = [...state.pages, ...state.layouts]\n      const plObj = pagesAndLayouts.find(\n        pl => pl.path === id || `LAYOUT___${pl.id}` === id\n      )\n      if (plObj) {\n        return queryRunner(plObj, state.components[plObj.component])\n      }\n      return null\n    },\n    { concurrency: Math.min(os.cpus().length, 32) }\n  )\n}\n\nconst findDirtyIds = actions => {\n  const state = store.getState()\n  return actions.reduce((dirtyIds, action) => {\n    const node = action.payload\n\n    // find invalid pagesAndLayouts\n    dirtyIds = dirtyIds.concat(state.componentDataDependencies.nodes[node.id])\n\n    // Find invalid connections\n    dirtyIds = dirtyIds.concat(\n      state.componentDataDependencies.connections[node.internal.type]\n    )\n\n    return _.compact(dirtyIds)\n  }, [])\n}\n\n"]}